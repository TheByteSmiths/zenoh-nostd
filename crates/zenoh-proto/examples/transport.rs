use zenoh_proto::{msgs::*, *};

fn session_process<'a, 'b>(
    session: &'a (),
    x: impl Iterator<Item = NetworkMessage<'b>>,
) -> impl Iterator<Item = NetworkMessage<'a>> {
    core::iter::from_fn(move || {
        let _ = (session, &x);
        None
    })
}

fn main() {
    let session = ();
    // Create a transport using stack-allocated buffers.
    // Heap-allocated buffers can be used as well.
    let mut transport = Transport::new([0u8; 512]).batch_size(256).streamed();

    loop {
        // Each iteration receives new bytes. Eventually between two states the bytes must be stored,
        // only if the tx/rx needs to interact, so we need a temporary (scoped) variation of the Transport
        // capable of retaining this state.
        // (This limitation will likely be addressed in the future.)
        let mut scope = transport.scope();

        // Feed the RX side with some bytes. See also `feed_with`.
        scope.rx.feed(&[1, 2, 3, 4, 5]);

        // Flush the RX buffer.
        // This consumes all available bytes and returns them as an iterator of `NetworkMessage`.
        // At this stage, no actual decoding is performed; you can call `.collect::<_>()`
        // to force full decoding immediately.
        let msgs = scope.rx.flush(&mut scope.state);

        // Simulate a `session_process` call.
        let session_resp = session_process(&session, msgs);

        // Consume the response and write it to the TX side.
        // The iterator yields chunks of bytes with a maximum size of `batch_size`.
        for bytes in scope.tx.write(session_resp) {
            println!("Sending {:?}", bytes);
        }

        // Finally, check whether the RX and TX sides need to interact.
        // If so, send the generated bytes.
        if let Some(bytes) = scope.tx.interact(&mut scope.state) {
            println!("Sending {:?}", bytes);
        }
    }
}
